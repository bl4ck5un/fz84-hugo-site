+++
title = "Why heart bleeds"
date = "2014-04-10"
tags = ["exploit", "SSL", "security", "networking"]
categories = ["Blog"]
+++

It's not rare that the critical security infrastructure on which we heavily reply sometimes is broken, in one way or another. This blog investigated the `Heartbeat` mechanism in TLS protocol and how it leads to the widely spread **HeartBleed** vulnerability, aka CVE-2014-0160 in `OpenSSL 1.0.1`.

Description from NVD
--------------------

The (1) `TLS` and (2) `DTLS` implementations in `OpenSSL 1.0.1` before `1.0.1g` do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to `d1_both.c` and `t1_lib.c`, aka the Heartbleed bug.

To [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0160)

Heartbeat Extension
---------------------

First let's have a look at the Heartbeat Extension. The **Heartbeat Extension** is a pretty new extension to the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols. Essentially the Heartbeat Extension is designed to provide a faster and light-weight keeping-alive mechanism, and DTLS protocol can use it to perform path MTU (PMTU) discovery as well. 

Generally speaking, the Heartbeat Extension works in a quite simple way. Clients peroidcally send ``HeartbeatRequest`` messages (including a random chosen payload) to server and the server respond with the exact copy of that payload. If the server's response matches with the original message, the clients can make sure that that *the server is not only alive but responsive. Of course all the messages exchanged during this routine is on top of TLS layer. (Precisely speaking, the Heartbeat protocol is a new protocol running on top of the Record Layer.)For details please refer to [RFC6520](https://tools.ietf.org/html/rfc6520).

Messages
--------

A natural question we're gonna ask is how can this simple mechanism go wrong? To answer this question, we need to know some nitty-gritty. First, data structure. According to RFC6520, a HeartBeat message consists of `type`, `length`, attached `payload` and `padding`.


```c
struct {
    HeartbeatMessageType type;
    uint16 payload_length;
    opaque payload[HeartbeatMessage.payload_length];
    opaque padding[padding_length];
} HeartbeatMessage;
```

Though the description in RFC is fairly clear and concise, I'd like to summarize several important and tangent facts for better understanding of CVE-2014-0160, 

+ The length of the `type` field is 1 byte, and the length of the `payload_length` is 2.
+ A HeartbeatMessage must be shorter than `TLSPlaintext.length`(TLS) or `DTLSPlaintext.length`(DTLS). (decided through peer negotiation, default is 2^14 Bytes
+ The ``padding_length`` must be at least 16.


Scene of the accident
-----------------------

So here is the vulnerable code in OpenSSL 1.0.1. Let's check step by step to see what would happen when server receives the following `message`:`char* message = "\x18\x03\x02\x00\x03\x01\x40\x00"`. A few legends,

- `18`   : Content type::Heartbeat
- `0302` : Major Version=3, Minor Version=2, indicates TLS 1.1 
- `0003` : Length = 3
- `01`   : TLS1_HB_REQUEST
- `4000` : 0x4000=2^14=16384, indicates 64-byte payload

Apparently, this packet is totally invalid, in that it claimed a non-existent 64 bytes payload. This is not hard to check at all, simply looking at the `length` of the whole packet and the `padding_length` is enough, because other parts is of fixed-length. However, OpenSSL didn't do this simple check. In other words, the above packet, though apparently invalid, will be treated as normal in the following function.

```c  
int
tls1_process_heartbeat(SSL *s)
{
  unsigned char *p = &s->s3->rrec.data[0], *pl;   // (1) p points to packet
  unsigned short hbtype;
  unsigned int payload;
  unsigned int padding = 16; /* Use minimum padding */

  /* Read type and payload length first */
  hbtype = *p++;        // (2) p gets advanced to point to `payload_length`
  n2s(p, payload);      // (3) payload = n2s(*p), p+=2
  pl = p;               // (4) p and pl points to payload

  if (s->msg_callback)
    s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
      &s->s3->rrec.data[0], s->s3->rrec.length,
      s, s->msg_callback_arg);

  if (hbtype == TLS1_HB_REQUEST)
    {
    unsigned char *buffer, *bp;
    int r;

    buffer = OPENSSL_malloc(1 + 2 + payload + padding);
    bp = buffer;      // (1) bp points to buffer

    /* Enter response type, length and copy payload */
    *bp++ = TLS1_HB_RESPONSE;    // (2) 1st byte: TYPE
    s2n(payload, bp);            // (3) 2-3 byte: payload_length
    memcpy(bp, pl, payload);     // (*) payload Bytes of secret copied **
    bp += payload;
    /* Random padding */
    RAND_pseudo_bytes(bp, padding);

    //... all secrets get sent to client ...
}

//fetched from ssl/ssl_locl.h
//  n2s(c, s)
//  s = c[0] || c[1] (|| stands for concatanation)
//  c = c + 2
# define n2s(c,s)  ((s=(((unsigned int)(c[0]))<< 8)| \
              (((unsigned int)(c[1])))),c+=2)
```

Suppose we call `tls1_process_heartbeat` with the crafted packet `"\x18\x03\x02\x00\x03\x01\x40\x00"`. What would happen is:

1. `p` points to the beginning of HeartBeat message, i.e. the byte `"\x01"`
2. `hbtype := TLS1_HB_REQUEST` and `p` points to `payload_length`, i.e. `"\x40\x00"
3. `payload := 0x4000`, `p` nows points to somewhere outside of the packet (note that packet has already ended, there is no payload at all!)
4. `memcpy(bp, pl, payload)` actually copied 64 bytes memory from `pl`, somewhere in stack, to the response packet that users that see in clear.


Fix and Conclusion
--------------------

As we saw before, it's fairly straightforward to fix this bug -- just check the length! It turned out basically just one line of C code can save the world. How surprising it is! Even though TLS is elegantly designed on board, even though the RFC is well written and carefully proof read, a single line of code can screw up everything. This bug reminds me of a sentence in Practical Cryptography:.


Official patch is attached for completeness.

```diff
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index b82fada..bddffd9 100644 (file)
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -2588,16 +2588,20 @@ tls1_process_heartbeat(SSL *s)
        unsigned int payload;
        unsigned int padding = 16; /* Use minimum padding */

-       /* Read type and payload length first */
-       hbtype = *p++;
-       n2s(p, payload);
-       pl = p;
-
        if (s->msg_callback)
                s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
                        &s->s3->rrec.data[0], s->s3->rrec.length,
                        s, s->msg_callback_arg);

+       /* Read type and payload length first */
+       if (1 + 2 + 16 > s->s3->rrec.length)
+               return 0; /* silently discard */
+       hbtype = *p++;
+       n2s(p, payload);
+       if (1 + 2 + payload + 16 > s->s3->rrec.length)
+               return 0; /* silently discard per RFC 6520 sec. 4 */
+       pl = p;
+
        if (hbtype == TLS1_HB_REQUEST)
                {
                unsigned char *buffer, *bp;
```
