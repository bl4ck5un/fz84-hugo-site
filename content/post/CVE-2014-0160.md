+++
title = "Why heart bleeds"
date = "2014-04-10"
tags = ["exploit", "SSL", "security", "networking"]
categories = [
    "Blog",
    "Exploit" ]
+++

This blog investigated the recently introduced Heartbeat mechanism in TLS, which unfortunately leads to the widely spread **HeartBleed** vulnerability, aka CVE-2014-0160. 

Description from NVD
--------------------

The (1) ``TLS`` and (2) ``DTLS`` implementations in ``OpenSSL 1.0.1`` before ``1.0.1g`` do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to ``d1_both.c`` and ``t1_lib.c``, aka the Heartbleed bug.

To [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-0160)

Heartbeat Extension
-------------------



The **Heartbeat Extension** is a new feature augmented for the Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) protocols. Basically the Heartbeat Extension is designed to provide a faster and light-weight keeping-alive mechanism, and DTLS protocol can use it to perform path MTU (PMTU) discovery as well. 

Generally speaking, the Heartbeat Extension works in a quite simple way, in which the client sends out a ``HeartbeatRequest`` message and the server respond it with an exact copy of payload to indicate that *I'm not only alive but conscious.* Of course all messages changed in this routine is on the top of TLS layer. (Precisely speaking, the Heartbeat protocol is a new protocol running on top of the Record Layer.)

To [RFC6520](https://tools.ietf.org/html/rfc6520)

Messages
--------

According to RFC6520, the HeartBeat protocol message consists of their type, attached payload and padding.


```c
struct {
    HeartbeatMessageType type;
    uint16 payload_length;
    opaque payload[HeartbeatMessage.payload_length];
    opaque padding[padding_length];
} HeartbeatMessage;
```

    
Though the description in RFC is fairly clear and concise, I'd like to summarize several important and tangent facts for understanding CVE-2014-0160, 

+ According to the RFC, The length of the ``type`` field is 1 byte, and the length of the ``payload_length`` is 2.
+ Padding can not be too large: The length of a HeartbeatMessage is ``TLSPlaintext.length`` for TLS and ``DTLSPlaintext.length`` for DTLS. (decided through peer negotiation, default is 2^14 Bytes(octets))
+ Nor can padding be too tiny: The ``padding_length`` MUST be at least 16.


Hits
----

See what will happen if we send this crafted HeartbeatRequest messages to the vulnerable server,

See [Wikipedia](http://en.wikipedia.org/wiki/Transport_Layer_Security)


```c
18 03 02 00 03 01 40 00

18   : Content type::Heartbeat
0302 : Major Version=3, Minor Version=2, indicates TLS 1.1 
0003 : Length = 3
01   : TLS1_HB_REQUEST
4000 : 0x4000=2^14=16384, indicates 64-byte length of payload
```

Request process happens in ``tls1_process_heartbeat`` function.
                

```c  
int
tls1_process_heartbeat(SSL *s)
{
  unsigned char *p = &s->s3->rrec.data[0], *pl;   // (1) p points to packet
  unsigned short hbtype;
  unsigned int payload;
  unsigned int padding = 16; /* Use minimum padding */

  /* Read type and payload length first */
  hbtype = *p++;        // (2) p gets advanced to point to `payload_length`
  n2s(p, payload);      // (3) payload = n2s(*p), p+=2
  pl = p;               // (4) p and pl points to payload

  if (s->msg_callback)
    s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
      &s->s3->rrec.data[0], s->s3->rrec.length,
      s, s->msg_callback_arg);

  if (hbtype == TLS1_HB_REQUEST)
    {
    unsigned char *buffer, *bp;
    int r;

    buffer = OPENSSL_malloc(1 + 2 + payload + padding);
    bp = buffer;      // (1) bp points to buffer

    /* Enter response type, length and copy payload */
    *bp++ = TLS1_HB_RESPONSE;    // (2) 1st byte: TYPE
    s2n(payload, bp);            // (3) 2-3 byte: payload_length
    memcpy(bp, pl, payload);     // (*) payload Bytes of secret copied **
    bp += payload;
    /* Random padding */
    RAND_pseudo_bytes(bp, padding);

    //... all secrets get sent to client ...
}
```


Fix
---


```diff
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index b82fada..bddffd9 100644 (file)
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -2588,16 +2588,20 @@ tls1_process_heartbeat(SSL *s)
        unsigned int payload;
        unsigned int padding = 16; /* Use minimum padding */

-       /* Read type and payload length first */
-       hbtype = *p++;
-       n2s(p, payload);
-       pl = p;
-
        if (s->msg_callback)
                s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
                        &s->s3->rrec.data[0], s->s3->rrec.length,
                        s, s->msg_callback_arg);

+       /* Read type and payload length first */
+       if (1 + 2 + 16 > s->s3->rrec.length)
+               return 0; /* silently discard */
+       hbtype = *p++;
+       n2s(p, payload);
+       if (1 + 2 + payload + 16 > s->s3->rrec.length)
+               return 0; /* silently discard per RFC 6520 sec. 4 */
+       pl = p;
+
        if (hbtype == TLS1_HB_REQUEST)
                {
                unsigned char *buffer, *bp;
```
